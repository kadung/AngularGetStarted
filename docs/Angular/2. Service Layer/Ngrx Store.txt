Ref:
    1. 

-------------------------------------------------------------------------------------------------------
    The Redux Pattern
-------------------------------------------------------------------------------------------------------
+ Redux pattern is a way to implement a predictable state container for Javascript app.

+ Redux pattern makes it easy to manage the state of your application by providing a one way data flow
through out the application

+ Redux princibles:
    - There is one single source of truth for application state called the Store.
    - State is read only and the only way to change State is to dispatch an Action.
    - Changes to the store are made using pure functions called Reducers.

+ State is entity data which is retrieved from backend server or the data from user inputs.

+ Store provides the single source of truth for the application. It is the one place that holds all of 
application state, this ensures that every component that accesses the state has a consistency results.
You do not have to put every piece of state in the store, expecially:
    - Unshared state that is solely owned by a single component that does not need to be shared
    or made available across routes
    - Angular forms don't belong in the store as they are usually self contained and do not need
    to be shared across multiple component, Angular forms also are not serializable or immutable 
    and can change themself meaning you will not be able to track those changes with actions
    - State that has cycles in it or has complex data structure that cannot be serialized, for
        example, the router state

+ Action presents the response to an event from a user which contain a type as a string and an 
optional payload that can be any type. 
    - All relevant user events are dispatched as actions, effecting reducers who update the store. 
    - If you need to change the state of the store, then replace the whole state object and not just
    mutate part of it.
    - Example action:
        {
            type: 'LOGIN',
            payload: {
                username: 'Duncan', 
                password: 'secrect'
            }
        }

+ Reducer responds to dispatched actions and replace the slice of state with new one based on action 
payload
    - Reducer is a pure function, accepting two arguments the previous state and an action dispatched 
    to update state. Reducer use switch statements to listen and act on specific action types, talking 
    the action payload and state and returning a new state.
    - Not all dispatched actions can directly update the store via a reducer as some actions have side
    effects. To manage side effect , we use the NgRx Effects library.
    - A pure function is a function which returns consistent results and does not mutate or access any
    properties outside of their function scope. For example:
        . Pure fucntion:
            function sum(a, b){
                return a + b;
            }
        . Impure fucntion:
            let c = 1;
            function sum(a, b){
                return a + b + c;
            } 


-------------------------------------------------------------------------------------------------------
    NgRx Store
-------------------------------------------------------------------------------------------------------
+ NgRx Store is the library which provides reactive state management for Angular apps inspired by Redux.

+ Store is a simple Javascript object contained all application state, each bit of the state is defined 
with a property, think of it as a client side database. Store is runtime only, so the state is not 
retained if user refreshes the page or exits the app.

+ Angular app often organized into feature module, so State in Store should be organized by feature
called feature module state composition. 

+ Each feature state is added to the application state once the feature is loaded, and called slices.
For example:
    {                                                                               |
        app: {                              |                                       |
            showImage: true,                |=> app slide (app module)              |
            pageTitle: 'ABC'                |                                       |
        },                                                                          |
        products: {                         |                                       |
            productList: {                  |                                       |
                showProductCode: true       |                                       |=> Store
            },                              |=> products slice (products module)    |
            productData: {                  |                                       |
                products: [...],            |                                       |
                productType: [...]          |                                       |
            }                                                                       |
        },                                                                          |
        ...                                                                         |
    }

+ Steps:
    1. Initialize Store with feature module state composition:
        - Initialize root application state in root app module by calling forRoot which takes according 
        reducer:
            imports: [
                StoreModule.forRoot({'app', appReducer})
                ...
            ]
        - Initialize each feature state in feature app module by calling forFeature which takes in the name
        of :
            imports: [
                StoreModule.forFeature('products', productReducer)
                ...
            ]
        - We can break a reducer to smaller pieces for one feature slice:
            imports: [
                StoreModule.forFeature('products', 
                    // Set of reducers for this slice as key and value pair
                    // The key is the name for each sub-slice of state
                    // The value is the reference to its reducers
                    {
                        productList: listReducer,
                        productData: dataReducer
                    }
                )
                ...
            ]

    2. Create a reducer to process action:
        - Create a reducer file in coresponding feature module.
        - Example reducer file include below function:
            // Default value for the state
            const initialState: any = {
                showProductCode: true,
                currentProduct: null,
                products: []
            }
            // Reducer function
            export function reducer(state = initialState, action) {
                switch (action.type) {
                    case 'TOGGLE_PRODUCT_CODE':
                    return {
                        // ... is Javascript shorthand for Object.assign which mean create a new copy of 
                        // of provided object
                        ...state,
                        showProductCode: action.payload
                    };
                    default:
                        return state;
                }
            }
        
    3. Dispatching an Action to Change State:
        - Before dispatch an action from a component, we must inject the Store into that component just 
        like any services using the constructor of that component:
            constructor(private store: Store<any>) {}
        - Then we can dispatch an action by calling Store's dispatch method. 
            checkChanged(value: boolean): void {
                this.store.dispatch({
                    'type': 'TOGGLE_PRODUCT_CODE',
                    'payload': value
                })
            }

    4. Subscribing to the Store to Get State Changes:
        - Subscribing to the Store often done in ngOnInit lifecycle hook. This provides any current 
        store value when the component is initialized and starts watching for change notification
        - To access a value in the store, we select the apporociated slice in state using the Store's
        select method and specifying the name of desired slice. 
            this.store.select('products');
        Or since the NgRx Store is an Observable, we can use pipe method and the select operator. The 
        benefit of pipe syntax is that we readily add other pipeable operators as needed.
            this.store.pipe(select('products'));
        - The NgRx select method returns a slice of state as an Observable. If we want the component to
        be notified of changes to the state, we subscribe to this observable in the component:
            this.store.pipe(select('products')).subscribe(
                // This is the next function which is executed each time it receives the next change 
                // notification from the store. So each time an action causes the reducer to replace
                // the state and showProductCode is changed, this component is notified and this code
                // is executed
                products => this.displayCode = products.showProductCode
            );

+ Selector is a resuable query of the Store.
    - The component uses the Selector to select state from the Store, adding a level of abstraction 
    between the Store structure and the component. 
    - Benefit of Selector:
        . Decouple the Store and the component so any components, which access the state, doesn't need 
        to update when the Store is changed (re-organize or split up)
        . Selector can encapsulate complex data transformation, make it easier for the component to
        obtain the complex data
        . Selector is resuable
        . Selectors are memorized 

-------------------------------------------------------------------------------------------------------
    Tools and Debugging
-------------------------------------------------------------------------------------------------------
+ Redux Store DevTools are the tools for visual analysis and debugging.

+ Install Redux Store DevTools in 3 steps:
    1. Install Chrome browser Redex DevTools extension.
    2. Install @ngrx/store-devtools package to the application.
        npm install @ngrx/store-devtools
    3. Initialize @ngrx/store-devtools in the root module.
        imports: [
            StoreDevtoolsModule.instrument({
                name: 'Demo App',
                maxAge: 25,
                logOnly: environment.production
            })
            ...
        ]


-------------------------------------------------------------------------------------------------------
    Strongly Typing the State
-------------------------------------------------------------------------------------------------------
+ State is organized into feature slices to keep the state associated with its feature module and makes
it easier to find and manage the state.

+ For each slice of state, we define an interface that describes the structure of that slice, then we
compose an global interface from all slice interfaces. This global interface defines entire state tree
of the application.

+ Feature slice interface should define in feature module reducer.

+ Global interface should define in a folder under app folder.


-------------------------------------------------------------------------------------------------------
    Strongly Typing Actions with Action Creators
-------------------------------------------------------------------------------------------------------
+ 



-------------------------------------------------------------------------------------------------------
    Working with Effects
-------------------------------------------------------------------------------------------------------
+ 



-------------------------------------------------------------------------------------------------------
    Performing Update Operations
-------------------------------------------------------------------------------------------------------
+ 


-------------------------------------------------------------------------------------------------------
    Architectural Considerations
-------------------------------------------------------------------------------------------------------
+ 